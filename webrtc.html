<!DOCTYPE html>
<html lang="en">

<head>
    <title>WebGL cubic interpolation: WebRTC Peer Connection</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <script src="gl.cubicinterpolation.js"></script>
    <script src="gl.eventhandlers.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f0f0f0; }
        .container { max-width: 1200px; margin: 0 auto; }
        .video-container { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
        .video-box { flex: 1; min-width: 400px; background: white; padding: 15px; border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .video-box h3 { margin-top: 0; color: #333; }
        canvas { border: 2px solid #ddd; border-radius: 4px; width: 100%; height: auto; max-width: 500px; }
        .controls { background: white; padding: 20px; border-radius: 8px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 20px; 
        }
        button { padding: 10px 20px; margin: 5px; font-size: 14px; cursor: pointer; background: #4CAF50;
            color: white; border: none; border-radius: 4px; transition: background 0.3s;
        }
        button:hover { background: #45a049; }
        button:disabled { background: #cccccc; cursor: not-allowed; }
        .signaling { margin-top: 20px; }
        textarea { width: 100%; height: 100px; margin: 10px 0; padding: 10px;
            font-family: monospace; font-size: 12px; border: 1px solid #ddd; border-radius: 4px;
        }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px;
            background: #e7f3ff; border-left: 4px solid #2196F3;
        }
        .error { background: #ffebee; border-left-color: #f44336; }
        .success { background: #e8f5e9; border-left-color: #4CAF50; }
    </style>
    
    <script>
        let localStream = null;
        let peerConnection = null;
        let localCanvas = null;
        let remoteCanvas = null;
        let signalingSocket = null;
        let myClientId = null;
        let remotePeerId = null;
        
        const SIGNALING_SERVER = 'ws://localhost:8080';
        
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        function connectToSignalingServer() {
            updateStatus('Connecting to signaling server...', 'status');
            
            try {
                signalingSocket = new WebSocket(SIGNALING_SERVER);
                
                signalingSocket.onopen = () => {
                    updateStatus('Connected to signaling server', 'success');
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = false;
                };
                
                signalingSocket.onmessage = async (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        await handleSignalingMessage(message);
                    } catch (error) {
                        console.error('Error handling signaling message:', error);
                        updateStatus(`Signaling error: ${error.message}`, 'error');
                    }
                };
                
                signalingSocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Failed to connect to signaling server', 'error');
                };
                
                signalingSocket.onclose = () => {
                    updateStatus('Disconnected from signaling server', 'error');
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = true;
                    signalingSocket = null;
                    myClientId = null;
                };
            } catch (error) {
                updateStatus(`Connection error: ${error.message}`, 'error');
            }
        }
        
        function disconnectFromServer() {
            if (signalingSocket) {
                signalingSocket.close();
            }
            stopVideo();
        }
        
        async function handleSignalingMessage(message) {
            console.log('Received signaling message:', message.type);
            
            switch (message.type) {
                case 'welcome':
                    myClientId = message.clientId;
                    updateStatus(`Connected as Client ${myClientId}. Total peers: ${message.totalClients - 1}`, 'success');
                    addLogMessage(`You are Client ${myClientId}`);
                    break;
                    
                case 'peer-connected':
                    if (message.clientId !== myClientId) {
                        addLogMessage(`Peer ${message.clientId} connected. Total peers: ${message.totalClients - 1}`);
                        updateStatus(`Peer ${message.clientId} available. Ready to call.`, 'success');
                        
                        // If we have local stream and no existing connection, automatically call
                        if (localStream && !peerConnection) {
                            setTimeout(() => {
                                remotePeerId = message.clientId;
                                createAndSendOffer(message.clientId);
                            }, 1000);
                        }
                    }
                    break;
                    
                case 'peer-disconnected':
                    addLogMessage(`Peer ${message.clientId} disconnected`);
                    if (remotePeerId === message.clientId) {
                        updateStatus('Remote peer disconnected', 'error');
                        if (peerConnection) {
                            peerConnection.close();
                            peerConnection = null;
                        }
                    }
                    break;
                    
                case 'offer':
                    addLogMessage(`Received offer from Client ${message.senderId}`);
                    await handleOffer(message.offer, message.senderId);
                    break;
                    
                case 'answer':
                    addLogMessage(`Received answer from Client ${message.senderId}`);
                    await handleAnswer(message.answer);
                    break;
                    
                case 'ice-candidate':
                    if (message.candidate && peerConnection) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                        console.log('Added ICE candidate from remote peer');
                    }
                    break;
            }
        }
        
        function sendSignalingMessage(message) {
            if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {
                signalingSocket.send(JSON.stringify(message));
            } else {
                console.error('Cannot send message: WebSocket not connected');
                updateStatus('Not connected to signaling server', 'error');
            }
        }
        
        function initVideoTexture(canvas, stream, canvasId) {
            let intervalID;
            const videoElement = document.createElement('video');
            videoElement.autoplay = true;
            videoElement.playsInline = true;
            videoElement.muted = (canvasId === 'local'); // Only mute local video
            videoElement.srcObject = stream;
            
            videoElement.addEventListener("canplaythrough", () => {
                videoElement.play().catch(err => { 
                    console.error("Error playing video:", err); 
                    updateStatus(`Error playing ${canvasId} video: ${err.message}`, 'error');
                });
                if (intervalID) clearInterval(intervalID);
                intervalID = setInterval(() => { 
                    handleLoadedImage(canvas, videoElement, videoElement.videoWidth, videoElement.videoHeight); 
                }, 15);
            });
            
            videoElement.addEventListener("ended", () => { 
                if (intervalID) clearInterval(intervalID); 
            });
            
            // Store reference for cleanup
            canvas.videoElement = videoElement;
            canvas.intervalID = intervalID;
        }

        async function startLocalVideo() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateStatus("getUserMedia is not supported in this browser", 'error');
                return;
            }
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 1280, height: 720 }, 
                    audio: true 
                });
                
                localCanvas = document.getElementById('localVideo');
                initCanvasGL(localCanvas);
                initVideoTexture(localCanvas, localStream, 'local');
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                updateStatus("Local camera started. Waiting for peer...", 'success');
                addLogMessage('Local camera started');
            } catch (error) {
                updateStatus(`Failed to get local stream: ${error.message}`, 'error');
                console.error("Error accessing media devices:", error);
            }
        }

        async function createPeerConnection() {
            peerConnection = new RTCPeerConnection(configuration);
            
            // Add local stream tracks to peer connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }
            
            // Handle incoming tracks
            peerConnection.ontrack = (event) => {
                console.log('Received remote track:', event.track.kind);
                
                if (!remoteCanvas) {
                    remoteCanvas = document.getElementById('remoteVideo');
                    initCanvasGL(remoteCanvas);
                }
                
                initVideoTexture(remoteCanvas, event.streams[0], 'remote');
                updateStatus("Remote stream received!", 'success');
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate to remote peer');
                    sendSignalingMessage({
                        type: 'ice-candidate',
                        candidate: event.candidate,
                        targetId: remotePeerId
                    });
                }
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                updateStatus(`Connection state: ${peerConnection.connectionState}`, 'status');
                console.log('Connection state:', peerConnection.connectionState);
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                updateStatus(`ICE connection state: ${peerConnection.iceConnectionState}`, 'status');
                console.log('ICE connection state:', peerConnection.iceConnectionState);
            };
        }

        async function createAndSendOffer(targetId) {
            try {
                remotePeerId = targetId;
                await createPeerConnection();
                
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                sendSignalingMessage({
                    type: 'offer',
                    offer: offer,
                    targetId: targetId
                });
                
                addLogMessage(`Sent offer to Client ${targetId}`);
                updateStatus(`Calling Client ${targetId}...`, 'status');
            } catch (error) {
                updateStatus(`Error creating offer: ${error.message}`, 'error');
                console.error("Error creating offer:", error);
            }
        }

        async function handleAnswer(answer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                updateStatus("Connected to remote peer!", 'success');
                addLogMessage('Connection established');
            } catch (error) {
                updateStatus(`Error handling answer: ${error.message}`, 'error');
                console.error("Error handling answer:", error);
            }
        }

        async function handleOffer(offer, senderId) {
            try {
                remotePeerId = senderId;
                
                if (!localStream) {
                    updateStatus('Received call but camera not started. Starting camera...', 'status');
                    await startLocalVideo();
                }
                
                await createPeerConnection();
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                sendSignalingMessage({
                    type: 'answer',
                    answer: answer,
                    targetId: senderId
                });
                
                addLogMessage(`Answered call from Client ${senderId}`);
                updateStatus(`Answering call from Client ${senderId}...`, 'status');
            } catch (error) {
                updateStatus(`Error handling offer: ${error.message}`, 'error');
                console.error("Error handling offer:", error);
            }
        }

        function stopVideo() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // Clear canvases
            if (localCanvas && localCanvas.intervalID) {
                clearInterval(localCanvas.intervalID);
            }
            if (remoteCanvas && remoteCanvas.intervalID) {
                clearInterval(remoteCanvas.intervalID);
            }
            
            remotePeerId = null;
            
            document.getElementById('startBtn').disabled = signalingSocket ? false : true;
            document.getElementById('stopBtn').disabled = true;
            
            updateStatus("Stopped all video streams", 'status');
            addLogMessage('Video stopped');
        }
        
        function addLogMessage(message) {
            const logDiv = document.getElementById('signalingLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStatus(message, type = 'status') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }

        function webGLStart() {
            const canvasArray = document.getElementsByClassName("gl.cubicinterpolation");
            for (let canvas of canvasArray) {
                addMouseEvents(canvas);
            }

            addEventHandlers(() => {
                const canvasArray = document.getElementsByClassName("gl.cubicinterpolation");
                for (let canvas of canvasArray) {
                    const gl = canvas.gl;
                    if (gl) {
                        gl.filterMode = (gl.filterMode + 1) % 4;
                        const texture = (gl.filterMode === 0) ? gl.rttFramebufferTextureY.texture : gl.myTexture;
                        cubicFilter(gl, texture, canvas.width, canvas.height);
                    }
                }
            });
            
            updateStatus("Ready. Connect to signaling server first.", 'status');
        }
        
        window.addEventListener('DOMContentLoaded', webGLStart);
    </script>        
</head>

<body>
    <div class="container">
        <h1>WebGL Cubic Interpolation with WebRTC</h1>
        
        <div class="controls">
            <h2>Controls</h2>
            <button id="connectBtn" onclick="connectToSignalingServer()">Connect to Server</button>
            <button id="startBtn" onclick="startLocalVideo()" disabled>Start Local Camera</button>
            <button id="stopBtn" onclick="stopVideo()" disabled>Stop Video</button>
            <button id="disconnectBtn" onclick="disconnectFromServer()" disabled>Disconnect</button>
            <div id="status" class="status">Initializing...</div>
            <p><em>Press 'F' to toggle filter mode. Use mouse wheel to zoom, click and drag to pan.</em></p>
        </div>
        
        <div class="video-container">
            <div class="video-box">
                <h3>Local Camera (You)</h3>
                <canvas id="localVideo" class="gl.cubicinterpolation" width="640" height="480"></canvas>
            </div>
            
            <div class="video-box">
                <h3>Remote Peer</h3>
                <canvas id="remoteVideo" class="gl.cubicinterpolation" width="640" height="480"></canvas>
            </div>
        </div>
        
        <div class="controls signaling">
            <h2>Signaling Log</h2>
            <div id="signalingLog" style="height: 200px; overflow-y: auto; background: #f9f9f9; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 12px;"></div>
        </div>
        
        <div class="controls">
            <h2>Instructions</h2>
            <ol>
                <li><strong>Start the signaling server:</strong> Run <code>node signaling-server.js</code> in the project directory</li>
                <li>Open this page in two browser windows or tabs (same computer or different devices on same network)</li>
                <li>In both windows, click "Connect to Server"</li>
                <li>In both windows, click "Start Local Camera" and allow camera access</li>
                <li>The peers will automatically connect via WebSocket signaling!</li>
                <li>You should see both local and remote video streams with WebGL cubic interpolation</li>
            </ol>
            <p><strong>Note:</strong> Make sure the signaling server is running on <code>ws://localhost:8080</code>. If using different devices, update the SIGNALING_SERVER constant in the code to use the server's IP address.</p>
        </div>
    </div>
</body>
    
</html>
